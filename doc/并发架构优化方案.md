# 并发架构优化方案

## 1. 概述

### 1.1 目标
通过并发架构大幅提升基金数据同步速度，从串行同步改为并行同步，预计可提升 **2-3 倍**速度。

### 1.2 性能基准（估算）

| 场景 | 串行 | 并发 | 提升 |
|------|------|------|------|
| 初始化同步（3 家基金公司） | ~45 秒 | ~15-20 秒 | 2-3x |
| 每日增量同步 | ~20 秒 | ~8-10 秒 | 2-3x |

---

## 2. 并发架构设计

### 2.1 并发层次

```
┌─────────────────────────────────────────────────────────┐
│                  FundSyncService                        │
│                                                         │
│  并发请求3个基金公司API（一次请求获取所有数据）           │
│  ┌──────────────┬──────────────┬──────────────┐         │
│  │  南方基金     │  博时基金     │  易方达基金   │         │
│  │  Extractor   │  Extractor   │  Extractor   │         │
│  │  817只基金   │  757只基金   │  859只基金   │         │
│  └──────┬───────┴──────┬───────┴──────┬───────┘         │
│         │              │              │                  │
│         ▼              ▼              ▼                  │
│  批量处理数据 + 批量数据库写入（非并发）                   │
└─────────────────────────────────────────────────────────┘
```

### 2.2 设计说明

**重要**：每个基金公司的API都只需要**一次请求**就能获取所有数据：
- **南方基金**：`POST /nfwebApi/fund/supermarket` → 返回817只基金（`g_index_allrelist`）
- **博时基金**：`GET /fund/index.html` → 返回757只基金（`window.fundListJson`）
- **易方达基金**：`GET /lm/jjcp/` → 返回859只基金（`__FUND_SUPER_MARKET_DATA__`）

因此并发只在**基金公司级别**（3个API并发请求），不需要基金级别的并发。

### 2.3 并发配置参数

```typescript
export const CONCURRENCY_CONFIG = {
  // 基金公司并发数（同时同步几个基金公司）
  FUND_SOURCE_CONCURRENCY: 3,

  // 数据库批量大小
  DB_BATCH_SIZE: 100,

  // 超时配置
  API_TIMEOUT_MS: 60000,
  DB_TIMEOUT_MS: 30000,
};
```

---

## 3. 实现方案

### 3.1 并发控制

使用 `Promise.allSettled` 并发请求3个基金公司API：

```typescript
import { prisma } from '../lib/prisma';
import { logger } from '../utils/logger';
import { NFFundExtractor } from './fundDataExtractors/nffundExtractor';
import { BoseraExtractor } from './fundDataExtractors/boseraExtractor';
import { EFundsExtractor } from './fundDataExtractors/efundsExtractor';

export class FundSyncService {
  private extractors = [
    new NFFundExtractor(),
    new BoseraExtractor(),
    new EFundsExtractor(),
  ];

  async syncAll(): Promise<SyncResults> {
    logger.info('[FundSync] Starting concurrent sync...');

    const startTime = Date.now();

    // 并发请求所有基金公司
    const syncPromises = this.extractors.map(async (extractor) => {
      const source = extractor.getSource();
      const sourceStartTime = Date.now();

      try {
        logger.info(`[FundSync] [${source}] Starting sync...`);

        // 一次性获取所有基金数据
        const funds = await extractor.fetch();
        logger.info(`[FundSync] [${source}] Fetched ${funds.length} funds`);

        // 批量写入数据库
        let success = 0;
        let failed = 0;

        for (const fund of funds) {
          try {
            await this.upsertFund(fund);
            success++;
          } catch (error) {
            logger.error(`[FundSync] [${source}] Failed to upsert ${fund.code}`, error);
            failed++;
          }
        }

        const duration = Date.now() - sourceStartTime;
        logger.info(`[FundSync] [${source}] Completed in ${duration}ms: ${success} success, ${failed} failed`);

        return { source, success, failed, duration };
      } catch (error) {
        const duration = Date.now() - sourceStartTime;
        logger.error(`[FundSync] [${source}] Failed after ${duration}ms`, error);
        return { source, success: 0, failed: 0, duration, error: error.message };
      }
    });

    // 等待所有同步完成（一个失败不影响其他）
    const results = await Promise.allSettled(syncPromises);

    // 聚合结果
    const aggregated: SyncResults = {};
    results.forEach((result, index) => {
      const source = this.extractors[index].getSource();

      if (result.status === 'fulfilled') {
        aggregated[source] = {
          success: result.value.success,
          failed: result.value.failed,
          duration: result.value.duration,
        };
      } else {
        aggregated[source] = {
          success: 0,
          failed: 0,
          error: result.reason.message,
        };
      }
    });

    const totalDuration = Date.now() - startTime;
    const totalSuccess = Object.values(aggregated).reduce((sum, r) => sum + r.success, 0);
    const totalFailed = Object.values(aggregated).reduce((sum, r) => sum + (r.failed || 0), 0);

    logger.info(`[FundSync] All completed in ${totalDuration}ms: ${totalSuccess} success, ${totalFailed} failed`);

    return aggregated;
  }

  private async upsertFund(fund: FundData): Promise<void> {
    await prisma.marketInstrument.upsert({
      where: {
        symbol_market: { symbol: fund.code, market: fund.market },
      },
      update: this.buildUpdateData(fund),
      create: this.buildCreateData(fund),
    });
  }

  private buildUpdateData(fund: FundData) {
    return {
      name: fund.name,
      lastPrice: fund.lastPrice,
      changePercent: fund.change,
      fundType: fund.fundType,
      riskLevel: fund.riskLevel,
      managerName: fund.managerName,
      yield7d: fund.yield7d,
      yield1m: fund.yield1m,
      yield3m: fund.yield3m,
      yield6m: fund.yield6m,
      yield1y: fund.yield1y,
      yieldYtd: fund.yieldYtd,
      yieldSinceInception: fund.yieldSinceInception,
      navDate: fund.navDate,
      setupDate: fund.setupDate,
      isActive: fund.isActive,
      lastSyncAt: new Date(),
    };
  }

  private buildCreateData(fund: FundData) {
    return {
      symbol: fund.code,
      name: fund.name,
      market: fund.market,
      type: fund.type,
      currency: 'CNY',
      ...this.buildUpdateData(fund),
    };
  }
}
```

### 3.2 批量写入优化（可选）

如果需要进一步提升性能，可以使用批量写入：

```typescript
export class FundSyncService {
  async syncAll(): Promise<SyncResults> {
    logger.info('[FundSync] Starting concurrent sync...');

    // 并发请求所有基金公司
    const syncPromises = this.extractors.map(async (extractor) => {
      const source = extractor.getSource();
      const sourceStartTime = Date.now();

      try {
        logger.info(`[FundSync] [${source}] Starting sync...`);

        const funds = await extractor.fetch();
        logger.info(`[FundSync] [${source}] Fetched ${funds.length} funds`);

        // 批量写入数据库（每批100条）
        const batchSize = 100;
        let success = 0;
        let failed = 0;

        for (let i = 0; i < funds.length; i += batchSize) {
          const batch = funds.slice(i, i + batchSize);

          try {
            await this.bulkUpsert(batch);
            success += batch.length;
          } catch (error) {
            logger.error(`[FundSync] [${source}] Batch upsert failed`, error);
            failed += batch.length;
          }
        }

        const duration = Date.now() - sourceStartTime;
        logger.info(`[FundSync] [${source}] Completed in ${duration}ms: ${success} success, ${failed} failed`);

        return { source, success, failed, duration };
      } catch (error) {
        const duration = Date.now() - sourceStartTime;
        logger.error(`[FundSync] [${source}] Failed after ${duration}ms`, error);
        return { source, success: 0, failed: 0, duration, error: error.message };
      }
    });

    const results = await Promise.allSettled(syncPromises);

    // ... 聚合结果
  }

  private async bulkUpsert(funds: FundData[]): Promise<void> {
    await prisma.$transaction(
      funds.map(fund =>
        prisma.marketInstrument.upsert({
          where: {
            symbol_market: { symbol: fund.code, market: fund.market },
          },
          update: this.buildUpdateData(fund),
          create: this.buildCreateData(fund),
        })
      )
    );
  }
}
```

---

## 4. 错误处理

### 4.1 错误隔离

使用 `Promise.allSettled` 确保一个失败不影响其他：

```typescript
const results = await Promise.allSettled(syncPromises);

results.forEach((result) => {
  if (result.status === 'rejected') {
    logger.error('[FundSync] Source failed', result.reason);
  }
});
```

### 4.2 重试机制

对于可重试的错误（网络超时、连接重置等）：

```typescript
export class FundSyncService {
  private maxRetries = 3;
  private retryDelay = 1000;

  private async syncSourceWithRetry(
    extractor: IFundDataExtractor,
    attempt: number = 1
  ): Promise<SourceResult> {
    try {
      return await this.syncSource(extractor);
    } catch (error) {
      if (attempt < this.maxRetries && this.isRetryableError(error)) {
        const delay = this.retryDelay * Math.pow(2, attempt - 1);
        logger.warn(`[FundSync] Retry attempt ${attempt + 1}/${this.maxRetries} for ${extractor.getSource()} after ${delay}ms`);

        await this.sleep(delay);
        return this.syncSourceWithRetry(extractor, attempt + 1);
      }

      throw error;
    }
  }

  private isRetryableError(error: any): boolean {
    return error.code === 'ETIMEDOUT' ||
           error.code === 'ECONNRESET' ||
           error.message?.includes('timeout') ||
           error.message?.includes('fetch failed');
  }

  private sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}
```

---

## 5. 性能监控

```typescript
export class FundSyncService {
  async syncAll(): Promise<SyncResults> {
    const startTime = Date.now();
    logger.info('[FundSync] Starting concurrent sync...');

    // ... 执行同步

    const totalDuration = Date.now() - startTime;
    const totalSuccess = Object.values(aggregated).reduce((sum, r) => sum + r.success, 0);
    const totalFailed = Object.values(aggregated).reduce((sum, r) => sum + (r.failed || 0), 0);
    const throughput = ((totalSuccess + totalFailed) / (totalDuration / 1000)).toFixed(2);

    logger.info(`[FundSync] Completed in ${totalDuration}ms`);
    logger.info(`[FundSync] Total: ${totalSuccess} success, ${totalFailed} failed`);
    logger.info(`[FundSync] Throughput: ${throughput} funds/s`);

    // 打印每个源的详细信息
    Object.entries(aggregated).forEach(([source, result]) => {
      logger.info(`[FundSync] [${source}] ${result.success} success, ${result.failed || 0} failed, ${result.duration}ms`);
    });

    return aggregated;
  }
}
```

---

## 6. 性能对比

### 6.1 串行 vs 并发

| 指标 | 串行 | 并发 | 提升 |
|------|------|------|------|
| **初始化同步** | | | |
| - 南方基金（817只） | ~15s | ~15s | - |
| - 博时基金（757只） | ~15s | ~15s | - |
| - 易方达基金（859只） | ~15s | ~15s | - |
| **总耗时** | ~45s | **~18s** | **2.5x** |
| **每日增量同步** | | | |
| - 假设 10% 数据变化 | ~20s | **~8s** | **2.5x** |

### 6.2 资源使用

| 指标 | 串行 | 并发 |
|------|------|------|
| **CPU 使用** | 5-10% | 15-25% |
| **内存使用** | 50MB | 100-150MB |
| **网络带宽** | 1 Mbps | 3 Mbps |
| **数据库连接** | 1 | 3 |

---

## 7. 注意事项

### 7.1 数据库连接池

确保 Prisma 连接池配置足够：

```env
DATABASE_URL="file:./dev.db?connection_limit=10&pool_timeout=20"
```

### 7.2 SQLite 并发限制

SQLite 对并发写入支持有限，建议：
1. 使用 WAL 模式（已默认启用）
2. 适当控制批量大小
3. 如果性能不足，考虑迁移到 PostgreSQL

### 7.3 API 超时

某些基金公司API响应较慢，建议设置足够的超时时间：

```typescript
const response = await proxiedFetch(url, {
  headers: { 'User-Agent': 'Mozilla/5.0' },
  timeout: 60000, // 60秒
});
```

---

## 8. 总结

并发架构优化可以带来 **2-3 倍**的性能提升，主要优势：

✅ **显著提速** - 从 45 秒降到 18 秒（初始化）
✅ **简单高效** - 只需并发3个API请求
✅ **错误隔离** - 一个失败不影响其他
✅ **易于维护** - 代码简洁，逻辑清晰
✅ **可扩展** - 轻松添加新的基金公司

建议先在开发环境验证，然后逐步推广到生产环境。
